{% load static %}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="{% static 'examples-styles.css' %}" />
    <link rel="stylesheet" href="{% static 'grids.css' %}" />
    <link rel="stylesheet" href="{% static 'styles.css' %}" />

    <link rel="icon" href="favicon.ico" type="image/x-icon" />
    <title>abcjs: Basic Synth Demo</title>
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">

    <!-- Bootstrap JavaScript -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <!-- <script src="{% static 'abcjs-plugin-min.js' %}"></script> -->

    <style>
        main {
            max-width: 770px;
            margin: 0 auto;
        }


        .status {
            padding: 2px 10px 10px 10px;
            background-color: #f0f0f0;
            width: 250px;
        }

        @media (prefers-color-scheme: dark) {
            .status {
                background-color: #000000;
            }
        }

        canvas {
            border: 1px solid black;
        }
    </style>

    <!-- <script src="../dist/abcjs-basic.js" type="text/javascript"></script> -->
    <script src="{% static 'abcjs-basic.js' %}"></script>
    <script type="module" src="{% static 'note_func.js' %}"></script>
    <!-- <script src="{% static 'soundfont-player.min.js' %}"></script> -->

    <!-- <script src="{% static 'myScript.js' %}"></script> -->
</head>

<body>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;

        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }
    </style>
    <!-- <div id="container"></div> -->
    <!-- Include jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <link rel="stylesheet" type="text/css" href="{% static 'abcjs-audio.css' %}">
    <!-- Include slider plugin's JavaScript and CSS files -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-slider/10.6.1/css/bootstrap-slider.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-slider/10.6.1/bootstrap-slider.min.js"></script>
    <div class="container-fluid" style="height: 60vh; margin-top: 2%;">
        <div class="h-100" style="display: flex;">
            <div class="col-3" style="display: flex;">
                <div class="indicator" id="tempo-indicator">
                    <div style="width: 100%; height: 20%;">
                        <label for="slider">Tempo</label>
                        <input type="range" data-slider-min="40" data-slider-max="200" data-slider-step="1"
                            data-slider-value="120" id="slider">
                        <!-- <input type="range" min="40" max="200" value="120" id="slider"> -->
                        <!-- <div id="slider-value"></div> -->
                    </div>
                </div>
            </div>
            <div class="col-8 h-100" style="display: flex;">
                <div class="col-12 h-100" id="matrix">
                    <div class="h-100" id="moving_box"></div>
                    <div id="invisible-text" style="display: none;"></div>

                </div>
                <div class="red-line">
                </div>
            </div>
            <div class="row col-1" id="left_box"></div>
            <!-- <div class="row col-1"></div> -->
        </div>
    </div>

    <script type="module">
        import { load } from "{% static 'note_func.js' defer%}";
        import { movingColors } from "{% static 'update_grid_coloring.js' defer%}";
        import { coloringInit } from "{% static 'grid_coloring.js' defer%}";
        import { generateColorArray, createTimeGrid } from "{% static 'grid_box_functions.js' defer%}";
        import { findCommonBeat, noteWeightening, beatPartitions, parseFraction, maxValuesByIndex, getNoteDurations, instrumentCounter, barTotalCountFinder, findLcm, parseAbc } from "{% static 'note_graphics_utilities.js' defer%}";
        var soundFontUrl = 'sample_url/'
        var abc = "X:1\n" +
            "M: 4/4\n" +
            "L: 1/4\n" +
            "K: Cmaj\n" +
            "T:Accidentals\n" +
            "|: e1/2d1/2e1/2d1/2 e2d2 e1e1 | d2e2 d1d1 |";

        // " E2E2 E2E2 | D2D2 D2D2 | C2C2 C2C2 | A2A2 A2A2 |]\n";
        // " |: c2c2 c2c2 | d2d2 d2d2 | c2c2 c2c2 | d2d2 d2d2 |\n" +
        // " c2c2 c2c2 | c2c2 c2c2 | d2d2 d2d2 | c2c2 c2c2 |]";

        // var xhr = new XMLHttpRequest();
        // var abc_url = 'abc_to_grid/';
        // xhr.open("GET", abc_url, true);
        const { timeSig, notes, barCounter } = parseAbc(abc);

        // Extract the numbers using a regular expression and convert them to integers
        const numbers = notes.match(/\d+/g).map(Number);

        // Calculate the LCM using a loop and the findLcm() function
        let lcm = 1;
        for (let i = 0; i < numbers.length; i++) {
            if (numbers[i] < 1)
                lcm = findLcm(lcm, 1 / numbers[i]);
            else
                lcm = findLcm(lcm, numbers[i]);
        }
        // var divisionNumber = innerPartitionGcd * partitionLcm;

        const instrumentCounts = instrumentCounter(notes)
        console.log("here");
        const noteDurations = getNoteDurations(notes);
        console.log("here");
        var barTotalCounts = barTotalCountFinder(notes);
        console.log("here");
        var noteMaxBeat = maxValuesByIndex(noteDurations);
        console.log("here");
        const partitions = beatPartitions(noteMaxBeat);
        const commonBeat = findCommonBeat(partitions);
        console.log("here ", noteDurations);
        const noteWeights = noteWeightening(noteDurations, commonBeat);
        console.log("noteWeights: ", noteWeights);
        const noteWeightsMax = maxValuesByIndex(noteWeights);
        console.log("noteWeightsMax: ", noteWeightsMax);

        // lcm = findGcd(parseInt(timeSig.split("/")[0]) * 2, lcm);
        // findGcd
        console.log("Time signature:", timeSig);
        console.log("Bar Counts:", barCounter);
        console.log("Notes:", notes);
        console.log("barTotalCounts:", barTotalCounts);
        // lcm = findLcm(parseInt(timeSig.split("/")[0]) * 2, lcm);
        console.log("LCM:", lcm);
        console.log("Number of Instruments:", instrumentCounts);
        console.log("Note Durations:", noteDurations);

        let extraBeatsPerWeight = 5;
        let barlinesMaxView = 10;
        let sharedVars = {
            isRunning: true,
            secondToMove: 1,
            stopInterval: 1,
        };
        let colorMatrix = createTimeGrid(extraBeatsPerWeight, barCounter, instrumentCounts, lcm, noteDurations, barTotalCounts, noteWeights, noteWeightsMax, barlinesMaxView);
        const windowSize = 140;
        let windowPosition = 0;
        coloringInit(colorMatrix);
        // applyColorMatrixWithWindow(colorMatrix, windowSize, windowPosition);
        // applyColorMatrix(colorMatrix);
        const extraBeats = extraBeatsPerWeight;
        const beatBarPerSecond = 60 / 120 / (2 * extraBeats);
        sharedVars.secondToMove = beatBarPerSecond;
        sharedVars.stopInterval = 0
        console.log('beatBarPerSecond = ' + beatBarPerSecond);
        const colorCalculationWorker = new Worker("{% static 'colorCalculationWorker.js' defer %}");
        const delayWorker = new Worker("{% static 'delayWorker.js' defer %}");
        // importWorkerScripts("{% static 'colorCalculationWorker.js' defer %}", "{% static 'delayWorker.js' defer %}");

        movingColors(colorCalculationWorker, delayWorker, sharedVars, colorMatrix, windowSize);

        let noteNumber = 0;
        let beatCount = 0;
        let barCount = -1;

        tempoSlider(sharedVars, extraBeatsPerWeight, noteWeightsMax, instrumentCounts, barCounter, barlinesMaxView);
        console.log(abc);

        load(abc, soundFontUrl);
    </script>

    <script>



    </script>
    <script>




        // function generateColorArray(noteWeights, extraBeats, noteWeightsMax) {
        //     const colorArray = [];

        //     const noteMap = {};
        //     let instCounter = 0;
        //     for (const key in noteWeights) {
        //         noteMap[key] = instCounter;
        //         instCounter += 1;
        //     }

        //     const colorMatrix = [];

        //     for (const key in noteWeights) {
        //         const instrument = noteMap[key];
        //         const durationValuesArray = noteWeights[key];
        //         let barlineCounter = 0;
        //         if (durationValuesArray[0] === "|") {
        //             barlineCounter = -1;
        //         }
        //         const instrumentColors = [];
        //         let beatPositionCounter = 0;

        //         for (let beatDurationIndex = 0; beatDurationIndex < durationValuesArray.length; beatDurationIndex++) {
        //             if (durationValuesArray[beatDurationIndex] === "|") {
        //                 barlineCounter += 1;
        //                 continue;
        //             }

        //             const beatDuration = durationValuesArray[beatDurationIndex];
        //             const beatDurationView = beatDuration * extraBeats;

        //             if (beatDurationView == 0) {
        //                 let whiteSpaces = noteWeightsMax[beatDurationIndex] * extraBeats;

        //                 for (let beatCount = 0; beatCount < whiteSpaces; beatCount++) {
        //                     instrumentColors.push("rgb(255, 255, 255)");
        //                     let box = document.getElementById(`box${instrument}-${barlineCounter}-${beatCount}-${beatDurationIndex}`);
        //                     box.setAttribute("data-beat-position", `box${instrument}-${beatPositionCounter}`);
        //                     beatPositionCounter += 1;
        //                 }
        //             }

        //             for (let beatCount = 0; beatCount < beatDurationView; beatCount++) {
        //                 const color = getColor(beatCount, beatDurationView);
        //                 instrumentColors.push(color);
        //                 let box = document.getElementById(`box${instrument}-${barlineCounter}-${beatCount}-${beatDurationIndex}`);
        //                 box.setAttribute("data-beat-position", `box${instrument}-${beatPositionCounter}`);
        //                 beatPositionCounter += 1;

        //             }
        //         }
        //         colorMatrix.push(instrumentColors);

        //     }

        //     return colorMatrix;
        // };









        // async function applyColorMatrixWithWindow(sharedVars, colorMatrix, windowSize) {
        //     const updateColors = (windowPosNow) => {
        //         for (let instrument = 0; instrument < colorMatrix.length; instrument++) {
        //             const instrumentColors = colorMatrix[instrument];
        //             const windowStart = Math.max(windowPosNow, 0);
        //             const windowEnd = Math.min(windowPosNow + windowSize, instrumentColors.length);

        //             for (let beatPosition = 0; beatPosition < instrumentColors.length; beatPosition++) {
        //                 let beatsToColorElement = document.querySelector(`[data-beat-position="box${instrument}-${beatPosition}"]`);

        //                 if (beatPosition + windowStart < windowEnd) {
        //                     const color = instrumentColors[beatPosition + windowStart];
        //                     beatsToColorElement.style.backgroundColor = color;
        //                 } else {
        //                     beatsToColorElement.style.backgroundColor = "rgb(255,255,255)";
        //                 }
        //             }
        //         }
        //     };

        //     for (let windowPosNow = 0; windowPosNow < colorMatrix[0].length; windowPosNow++) {
        //         let testTimer = performance.now();
        //         let startTime = performance.now();

        //         await new Promise((resolve) => {
        //             requestAnimationFrame(() => {
        //                 updateColors(windowPosNow);
        //                 resolve();
        //             });
        //         });

        //         let endTime = performance.now();
        //         let elapsedTime = endTime - startTime;
        //         let delayTime = sharedVars.secondToMove * 1000 - elapsedTime - 10;
        //         await delay(delayTime);
        //         let endTest = performance.now();
        //         console.log(endTest - testTimer, sharedVars.secondToMove * 1000);
        //     }
        // }


        function getColor(index, total) {
            const r = Math.floor((255 / total) * (total - index));
            const g = Math.floor((255 / total) * index);
            const b = 0;
            return `rgb(${r}, ${g}, ${b})`;
        }

        function durationMax(durations) {
            var durationGuide = [];
            for (let col = 0; col < durations[0].length; col++) {
                let columnValues = [];
                for (let row = 0; row < durations.length; row++) {
                    columnValues.push(durations[row][col]);
                }
                durationGuide.push(Math.max(...columnValues));
            }
            return durationGuide
        }

        function removeAndAttach(barline, barlineToShow, beatCount, noteNumber, numInstrument, barCount, secondToMove, callback) {

            // console.log("barCount: ", barCount);
            // Get the box to be removed and the box to be added
            const movingBox = document.getElementById('moving_box');
            // const boxWidth = 100 / (barlineToShow * numBeats);
            for (let instrument = 0; instrument < numInstrument; instrument++) {
                let movingBeat = document.getElementById('box' + instrument.toString() + "-" + barCount.toString() + "-" + beatCount.toString() + "-" + noteNumber.toString());
                // console.log('box' + instrument.toString() + "-" + barCount.toString() + "-" + beatCount.toString() + "-" + noteNumber.toString());
                const rowDiv = document.getElementById('row' + instrument.toString());
                const extraRowDiv = document.getElementById('extraRow' + instrument.toString());

                movingBeat.style.transition = `transform ${secondToMove * 1000}ms`;
                movingBeat.style.transform = `translateX(-100%)`;

                // console.log(movingBeat);
                let extraDivsToRotate = (barline - barlineToShow) <= 0 ? false : true;
                // console.log(extraDivsToRotate)
                // Remove movingBeat element after transition is complete
                // setTimeout(() => {
                movingBeat.style.opacity = '0';

                // take from first of show queue and append to end of reserve queue
                rowDiv.removeChild(movingBeat);

                if (extraDivsToRotate) {
                    extraRowDiv.appendChild(movingBeat);
                    movingBeat = extraRowDiv.children[0];
                    extraRowDiv.removeChild(movingBeat);
                }
                rowDiv.append(movingBeat);
                movingBeat.style.opacity = '1';
                movingBeat.style.transform = 'translateX(0)';
            }
            // console.log(timeOutId);
        };
        // function delay(time) {
        //     return new Promise((resolve) => setTimeout(resolve, time));
        // }

        async function Repeat(sharedVars, noteNumber, beatCount, barCount, noteWeightsMax, extraBeats, numInstrument, barline, barlineToShow, callback) {
            let counter = 0;
            let extraCounter = 0;

            while (counter < sharedVars.stopInterval) {
                let startTime2 = performance.now();

                while (sharedVars.isRunning && noteNumber < noteWeightsMax.length) {
                    if (noteWeightsMax[noteNumber] == "|") {
                        barCount += 1;
                        noteNumber++;
                        continue;
                    }
                    beatDurationMax = noteWeightsMax[noteNumber] * extraBeats;

                    for (beatCount; beatCount < beatDurationMax; beatCount++) {
                        extraCounter += 1;
                        let startTime = performance.now();

                        if (!sharedVars.isRunning) {
                            break;
                        }

                        removeAndAttach(barline, barlineToShow, beatCount, noteNumber, numInstrument, barCount, sharedVars.secondToMove);

                        if (callback) {
                            callback(noteNumber, beatCount, barCount);
                        };

                        let endTime = performance.now();
                        let elapsedTime = endTime - startTime;
                        let delayTime = sharedVars.secondToMove * 1000 - elapsedTime;
                        if (delayTime < 0) delayTime = 0; // Ensure non-negative delay

                        await delay(delayTime);

                        // Print the duration of the iteration
                        let iterationEndTime = performance.now();
                        console.log(`Iteration time: ${iterationEndTime - startTime} milliseconds`);
                    };
                    beatCount = 0;
                    noteNumber++;
                }

                let endTime2 = performance.now();
                let elapsedTime2 = endTime2 - startTime2;
                console.log(`Elapsed2 time: ${elapsedTime2} milliseconds`);
                counter += 1;
            }
            sharedVars.stopInterval = 0;
        }

        // async function Repeat(sharedVars, noteNumber, beatCount, barCount, noteWeightsMax, extraBeats, numInstrument, barline, barlineToShow, callback) {
        //     let counter = 0;
        //     let extraCounter = 0;

        //     while (counter < sharedVars.stopInterval) {
        //         let startTime2 = performance.now();

        //         while (sharedVars.isRunning && noteNumber < noteWeightsMax.length) {
        //             if (noteWeightsMax[noteNumber] == "|") {
        //                 barCount += 1;
        //                 noteNumber++;
        //                 continue;
        //             }
        //             beatDurationMax = noteWeightsMax[noteNumber] * extraBeats;

        //             for (beatCount; beatCount < beatDurationMax; beatCount++) {
        //                 extraCounter += 1;
        //                 let startTime = performance.now();

        //                 if (!sharedVars.isRunning) {
        //                     break;
        //                 }

        //                 removeAndAttach(barline, barlineToShow, beatCount, noteNumber, numInstrument, barCount, sharedVars.secondToMove);

        //                 if (callback) {
        //                     callback(noteNumber, beatCount, barCount);
        //                 };

        //                 let endTime = performance.now();
        //                 let elapsedTime = endTime - startTime;
        //                 let delayTime = sharedVars.secondToMove * 1000 - elapsedTime;
        //                 if (delayTime < 0) delayTime = 0; // Ensure non-negative delay

        //                 await delay(delayTime);

        //                 // Print the duration of the iteration
        //                 let iterationEndTime = performance.now();
        //                 console.log(`Iteration time: ${iterationEndTime - startTime} milliseconds`);
        //             };
        //             beatCount = 0;
        //             noteNumber++;
        //         }

        //         let endTime2 = performance.now();
        //         let elapsedTime2 = endTime2 - startTime2;
        //         console.log(`Elapsed2 time: ${elapsedTime2} milliseconds`);
        //         counter += 1;
        //     }
        //     sharedVars.stopInterval = 0;
        // }
        // // Repeating key will use this function
        // async function Repeat(sharedVars, noteNumber, beatCount, barCount, noteWeightsMax, extraBeats, numInstrument, barline, barlineToShow, callback) {
        //     // let isRunning = true;

        //     // let stopInterval = sharedVars.stopInterval
        //     //stopInterval -1 for infinity
        //     let counter = 0;

        //     counter = 0;
        //     let extraCounter = 0;
        //     while (counter < sharedVars.stopInterval) {
        //         let startTime2 = performance.now();
        //         while (sharedVars.isRunning && noteNumber < noteWeightsMax.length) {
        //             // console.log("wtf", sharedVars.isRunning);
        //             if (noteWeightsMax[noteNumber] == "|") {
        //                 barCount += 1;
        //                 noteNumber++;
        //                 continue;
        //             }
        //             beatDurationMax = noteWeightsMax[noteNumber] * extraBeats;
        //             // console.log("noteNumber is: ", noteNumber, beatDurationMax);
        //             // let currentBarCount = barCount;
        //             let timeList = [];
        //             let goalAvgDelay = 0;
        //             let currentAvg = 0;
        //             for (beatCount; beatCount < beatDurationMax; beatCount++) {
        //                 extraCounter += 1;
        //                 if (goalAvgDelay == 0) {
        //                     goalAvgDelay = sharedVars.secondToMove * 1000;
        //                 }
        //                 let startTime = performance.now();
        //                 console.log("wtf", sharedVars.isRunning);
        //                 if (!sharedVars.isRunning) {
        //                     break;
        //                 }
        //                 removeAndAttach(barline, barlineToShow, beatCount, noteNumber, numInstrument, barCount, sharedVars.secondToMove, () => {
        //                     // console.log("Repeat function complete");
        //                 });
        //                 if (callback) {
        //                     callback(noteNumber, beatCount, barCount);
        //                     // console.log("a " + intervalId, beatCount, barCount);
        //                 };
        //                 if (currentAvg == 0)
        //                     await delay(sharedVars.secondToMove);
        //                 else
        //                     await delay(sharedVars.secondToMove - (currentAvg / 1000 - sharedVars.secondToMove));
        //                 let endTime = performance.now();
        //                 let elapsedTime = endTime - startTime;
        //                 timeList.push(elapsedTime);
        //                 currentAvg = timeList.reduce((sum, value) => sum + value, 0) / timeList.length;
        //                 // goalAvgDelay = goalAvgDelay - (currentAvg - goalAvgDelay);
        //                 console.log(`Elapsed time: ${currentAvg} milliseconds`, sharedVars.secondToMove - (currentAvg / 1000 - sharedVars.secondToMove));

        //             };
        //             beatCount = 0;
        //             noteNumber++;

        //         }
        //         let endTime2 = performance.now();
        //         let elapsedTime2 = endTime2 - startTime2;
        //         console.log(`Elapsed2 time: ${elapsedTime2} milliseconds`);
        //         counter += 1
        //         break;
        //     }
        //     sharedVars.stopInterval = 0

        // }

        // if (beatCount == numBeats) {
        //     beatCount = 0;
        //     barCount += 1;
        // }
        // if (barCount == barline)
        //     barCount = 0;
        // counter += 1;
        // removeAndAttach(barline, barlineToShow, beatCount, numBeats, numInstrument, barCount, secondToMove, () => {
        //     // console.log("Repeat function complete");
        // });
        // beatCount += 1;



        // for (let beatDurationIndex = 0; beatDurationIndex < durationValuesArray.length; beatDurationIndex++) {
        //     if (durationValuesArray[beatDurationIndex] === "|") {
        //         barlineCounter += 1;
        //         elem += 1;
        //         continue;
        //     }
        //     beatDuration = durationValuesArray[beatDurationIndex];
        //     beatDurationView = beatDuration * extraBeats;
        //     console.log(beatDurationView);

        //     for (let beatCount = 0; beatCount < beatDurationView; beatCount++) {
        //         // currentBeatCounter = beatDurationView + beatCount
        //         console.log(beatCount, beatDurationView);
        //         // console.log("id: ", "box" + instrument.toString() + "-" + barlineCounter.toString() + "-" + beatCount.toString() + "-" + elem.toString())
        //         let beatsToColorElement = document.getElementById("box" + instrument.toString() + "-" + barlineCounter.toString() + "-" + beatCount.toString() + "-" + beatDurationIndex.toString())
        //         const color = getColor(beatCount, beatDurationView);
        //         beatsToColorElement.style.backgroundColor = color;
        //     }

        // }

    </script>


    <script>
        function tempoSlider(sharedVars, extraBeats, noteWeightsMax, instrumentCounts, barCounter, barlinesMaxView) {

            const slider = document.getElementById("slider");
            const sliderValue = document.getElementById('slider-value');

            let noteNumber = 0;
            let beatCount = 0;
            let barCount = -1;

            let intervalId = 0;

            $('#slider').slider({
                tooltip: 'always',
                tooltip_position: 'bottom'
            }).on('change', function () {
                updateIndicator($(this).slider('getValue'));
            });
            // sliderValue.style.setProperty('--value', slider.value);

            // // Update the slider value display on change
            // slider.addEventListener('input', () => {
            //     // Update the position and text of the slider value display
            //     sliderValue.style.setProperty('--value', slider.value);
            //     sliderValue.style.left = `calc(100% / 100 * var(--value) - 10px)`;
            //     sliderValue.textContent = slider.value;
            // });


            function updateIndicator(sliderValue) {
                console.log("tempo is: ", sliderValue);
                let updateBeatBarPerSecond = 60 / sliderValue / (2 * extraBeats);
                console.log("before repeat ", noteNumber, beatCount, barCount, updateBeatBarPerSecond);
                // sharedVars.isRunning = false;
                sharedVars.secondToMove = updateBeatBarPerSecond;
                sharedVars.isRunning = true;

                // if (sharedVars.stopInterval == 0) {
                //     sharedVars.stopInterval += 1;
                //     movingColors(sharedVars, 0, 0, -1, noteWeightsMax, extraBeats, instrumentCounts, barCounter, barlinesMaxView)
                // }
                // Repeat(sharedVars, noteNumber, beatCount, barCount, noteWeightsMax, extraBeats, instrumentCounts, barCounter, barlinesMaxView, updateBeatBarPerSecond, 1, (noteNumber, beatCount, barCount) => {
                //     noteNumber = noteNumber;
                //     beatCount = beatCount;
                //     barCount = barCount;
                //     // console.log("1", noteNumber, beatCount, barCount);
                // });
                // sharedVars.isRunning = true;

                // Repeat(true, noteNumber, beatCount, barCount, noteWeightsMax, extraBeats, instrumentCounts, barCounter, barlinesMaxView, updateBeatBarPerSecond, 1, (noteNumber, beatCount, barCount) => {
                //     noteNumber = noteNumber;
                //     beatCount = beatCount;
                //     barCount = barCount;
                //     // console.log("1", noteNumber, beatCount, barCount);
                // });
            }

            slider.addEventListener("input", () => {
                updateIndicator();
                // You can add more code here to update the tempo or graph
            });
        }
    </script>
    <main>
        <div class="container">
            <div id="paper"></div>
            <div class="row">
                <div>
                    <div id="audio" class="abcjs-large"></div><button class="activate-audio">Activate Audio</button>
                    <button class="start">Start</button>

                    <button class="activate-audio">Activate Audio Context And Play</button>
                    <button class="stop-audio" style="display:none;">Stop Audio</button>
                    <div class='audio-error' style="display:none;">Audio is not supported in this browser.</div>
                </div>
                <div class="status"></div>
            </div>
        </div>
    </main>

    <style>
        .abcjs-highlight {
            fill: #0a9ecc;
        }

        .abcjs-cursor {
            stroke: red;
        }
    </style>
</body>

</html>